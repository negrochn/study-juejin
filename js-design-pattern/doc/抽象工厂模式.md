# 抽象工厂模式

**抽象工厂模式**

- 抽象工厂（抽象类，它不能被用于生成具体实例）
  用于声明最终目标产品的共性，被称为“产品族”。
- 具体工厂（用于生成产品族里的一个具体的产品）
  继承自抽象工厂，实现抽象工厂里声明的方法，用于创建具体的产品的类。
- 抽象产品（抽象类，它不能被用于生成具体实例）
  细粒度产品的共性抽离的抽象产品类。
- 具体产品（用于生产产品族里的一个具体的产品所依赖的更细粒度的产品）

```js
// 开一个山寨手机工厂，准备操作系统和硬件。

// 抽象工厂
class MobilePhoneFactory {
  // 提供操作系统的接口
  createOS() {
    throw new Error('抽象工厂方法不允许直接调用，你需要将我重写！')
  }
  // 提供硬件的接口
  createHardWare() {
    throw new Error('抽象工厂方法不允许直接调用，你需要将我重写！')
  }
}

// 抽象工厂不干活，具体工厂来干活
// 抽象工厂继承自抽象工厂
class FakeStarFactory extends MobilePhoneFactory {
  createOS() {
    // 提供安卓系统实例
    return new AndroidOS()
  }
  createHardWare() {
    // 提供高通硬件实例
    return new QualcommHardWare()
  }
}

// 定义操作系统这类产品的抽象产品类
class OS {
  controlHardWare() {
    throw new Error('抽象产品方法不允许直接调用，你需要将我重写！')
  }
}

// 定义具体操作系统的具体产品类
class AndroidOS extends OS {
  controlHardWare() {
    console.log('我会用安卓的方式去操作硬件')
  }
}

class iOS extends OS {
  controlHardWare() {
    console.log('我会用苹果的方式去操作硬件')
  }
}

// 定义手机硬件这类产品的抽象产品类
class HardWare {
  // 手机硬件的共性方法，这里提取了“根据命令运转”这个共性
  operateByOrder() {
    throw new Error('抽象产品方法不允许直接调用，你需要将我重写！')
  }
}

// 定义具体硬件的具体产品类
class QualcommHardWare extends HardWare {
  operateByOrder() {
    console.log('我会用高通的方式去运转')
  }
}

class AHardWare extends HardWare {
  operateByOrder() {
    console.log('我会用苹果的方式去运转')
  }
}
```

```js
// 这是我的手机
const myPhone = new FakeStarFactory()
// 让它拥有操作系统
const myOS = myPhone.createOS()
// 让它拥有硬件
const myHardWare = myPhone.createHardWare()

myOS.controlHardWare() // 我会用安卓的方式去操作硬件
myHardWare.operateByOrder() // 我会用高通的方式去运转
```

```js
// 加入有一天，FakeStar 过气了，需要产出一款新机投入市场，
// 不需要对抽象工厂 MobilePhoneFactory 做任何修改，只需要拓展它的种类
class NewStarFactory extends MobilePhoneFactory {
  createOS() {
    // 操作系统实现代码
  }
  createHardWare() {
    // 硬件实现代码
  }
}
// 对原有的系统不会造成任何潜在影响
// 对扩展开放，对修改封闭
```

